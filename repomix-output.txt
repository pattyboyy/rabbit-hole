This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-28T05:02:55.579Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Directory Structure
================================================================
src/
  app/
    api/
      explore/
        route.ts
    globals.css
    layout.tsx
    page.tsx
  components/
    Breadcrumbs.tsx
    ExplorationLayout.tsx
    ExplorationStats.tsx
    ExplorationTree.tsx
  config/
    env.ts
  context/
    ExplorationContext.tsx
  lib/
    claude.ts
  types/
    css.d.ts
    index.ts
  env.d.ts
.gitignore
next.config.js
package.json
postcss.config.js
tailwind.config.js
terminal
tsconfig.json

================================================================
Files
================================================================

================
File: src/app/api/explore/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import { v4 as uuidv4 } from 'uuid';
import { generateTopicExploration } from '@/lib/claude';

// Assuming the structure of subtopics and connections
interface Subtopic {
  id: string;
  title: string;
  description: string;
  keyTerms: Array<{
    name: string;
    definition: string;
  }>;
  examples: Array<{
    title: string;
    description: string;
  }>;
}

interface Connection {
  id: string;
  title: string;
  description: string;
  examples: string[];
  research: string;
}

interface Context {
  historical: {
    evolution: string;
    keyEvents: Array<{
      date: string;
      description: string;
    }>;
  };
  current: {
    state: string;
    trends: string;
    challenges: string;
  };
  cultural: {
    perspectives: string;
    impact: string;
  };
}

interface ExpertOpinion {
  id: string;
  expert: string;
  quote: string;
  context: string;
  source: string;
}

interface Application {
  id: string;
  title: string;
  description: string;
  caseStudy: string;
  challenges: string;
  solutions: string;
}

export async function POST(request: NextRequest) {
  try {
    // Validate request body
    const body = await request.json().catch(() => null);
    if (!body?.topic) {
      return NextResponse.json(
        { error: 'Missing required field: topic' },
        { status: 400 }
      );
    }

    const { topic, parentId, depth = 0 } = body;

    console.log('Processing exploration request:', { topic, parentId, depth });

    const exploration = await generateTopicExploration(
      topic,
      depth > 0 ? `This is a subtopic of: ${parentId}` : ''
    );

    // Construct the response with enhanced data
    const explorationData = {
      id: uuidv4(),
      title: topic,
      summary: exploration.summary,
      subtopics: exploration.subtopics.map((st: any) => ({
        id: uuidv4(),
        title: st.title,
        description: st.description,
        keyTerms: st.keyTerms?.map((term: any) => ({
          name: term.name,
          definition: term.definition
        })) || [],
        examples: st.examples?.map((ex: any) => ({
          title: ex.title,
          description: ex.description
        })) || [],
        exploreDeeper: st.exploreDeeper?.map((path: any) => ({
          title: path.title,
          description: path.description,
          concepts: path.concepts,
          relevantTopics: path.relevantTopics,
          researchAreas: path.researchAreas
        })) || []
      })),
      connections: exploration.connections?.map((conn: any) => ({
        id: uuidv4(),
        title: conn.title,
        description: conn.description
      })) || [],
      depth
    };

    console.log('Exploration data:', JSON.stringify(explorationData, null, 2));
    return NextResponse.json(explorationData);
  } catch (error) {
    console.error('Error in explore API:', error);
    if (error instanceof Error) {
      console.error('Error details:', {
        message: error.message,
        stack: error.stack,
        name: error.name
      });
    }

    // Return a more specific error message if possible
    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
    return NextResponse.json(
      { error: errorMessage },
      { status: 500 }
    );
  }
}

================
File: src/app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0;
  --background-rgb: 255, 255, 255;
}

body {
  color: rgb(var(--foreground-rgb));
  background: rgb(var(--background-rgb));
}

================
File: src/app/layout.tsx
================
import React from 'react';
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import { ExplorationProvider } from '@/context/ExplorationContext';
import ExplorationLayout from '@/components/ExplorationLayout';

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Rabbit Hole - Knowledge Exploration Platform",
  description: "Infinitely explore any topic through AI-generated layers",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className={inter.className} suppressHydrationWarning>
        <ExplorationProvider>
          <ExplorationLayout>
            {children}
          </ExplorationLayout>
        </ExplorationProvider>
      </body>
    </html>
  );
}

================
File: src/app/page.tsx
================
'use client';

import React, { useState } from 'react';
import { Topic } from '@/types';
import { useExploration } from '@/context/ExplorationContext';

export default function Home() {
  const [searchTerm, setSearchTerm] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const { currentTopic, setCurrentTopic, addToExploration } = useExploration();

  const handleSearch = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (!searchTerm.trim()) return;

    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/explore', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ 
          topic: searchTerm.trim(),
          depth: 0
        }),
      });
      
      const data = await response.json();
      
      if (!response.ok) {
        throw new Error(data.error || 'Failed to fetch topic');
      }
      
      setCurrentTopic(data);
      addToExploration('root', data);
    } catch (error) {
      console.error('Error fetching topic:', error);
      setError(error instanceof Error ? error.message : 'Failed to fetch topic');
    } finally {
      setIsLoading(false);
    }
  };

  const handleSubtopicClick = async (subtopic: { id: string; title: string }) => {
    if (!currentTopic) return;
    
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/explore', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          topic: subtopic.title,
          parentId: currentTopic.id,
          depth: currentTopic.depth + 1
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Failed to fetch subtopic');
      }

      setCurrentTopic(data);
      addToExploration(currentTopic.id, data);
    } catch (error) {
      console.error('Error fetching subtopic:', error);
      setError(error instanceof Error ? error.message : 'Failed to fetch subtopic');
    } finally {
      setIsLoading(false);
    }
  };

  const handleExplorePathClick = async (path: { title: string; description: string }) => {
    if (!currentTopic) return;
    
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/explore', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          topic: path.title,
          parentId: currentTopic.id,
          depth: currentTopic.depth + 1,
          context: path.description // Pass the path description as context
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Failed to fetch path');
      }

      setCurrentTopic(data);
      addToExploration(currentTopic.id, data);
    } catch (error) {
      console.error('Error fetching path:', error);
      setError(error instanceof Error ? error.message : 'Failed to fetch path');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="h-full flex flex-col gap-4">
      <form onSubmit={handleSearch} className="flex gap-2">
        <input
          type="text"
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          placeholder="Enter a topic to explore..."
          className="flex-1 p-2 border rounded"
          disabled={isLoading}
        />
        <button 
          type="submit"
          className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed"
          disabled={isLoading || !searchTerm.trim()}
        >
          {isLoading ? 'Exploring...' : 'Explore'}
        </button>
      </form>

      {error && (
        <div className="p-4 bg-red-50 border border-red-200 rounded text-red-600">
          {error}
        </div>
      )}

      {isLoading && !currentTopic && (
        <div className="flex-1 flex items-center justify-center text-gray-500">
          Exploring your topic...
        </div>
      )}

      {!isLoading && !error && currentTopic ? (
        <div className="flex-1 overflow-y-auto">
          <h1 className="text-2xl font-bold mb-4">{currentTopic.title}</h1>
          <p className="mb-6">{currentTopic.summary}</p>
          
          <h2 className="text-xl font-semibold mb-3">Explore Deeper</h2>
          <div className="grid grid-cols-1 gap-6">
            {currentTopic.subtopics.map((subtopic) => (
              <div key={subtopic.id} className="border rounded-lg p-6">
                <h3 className="text-lg font-semibold mb-2">{subtopic.title}</h3>
                <p className="text-gray-600 mb-4">{subtopic.description}</p>
                
                {subtopic.keyTerms && subtopic.keyTerms.length > 0 && (
                  <div className="mb-4">
                    <h4 className="font-medium mb-2">Key Terms</h4>
                    <div className="grid grid-cols-2 gap-4">
                      {subtopic.keyTerms.map((term, idx) => (
                        <div key={idx} className="bg-gray-50 p-3 rounded">
                          <div className="font-medium">{term.name}</div>
                          <div className="text-sm text-gray-600">{term.definition}</div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}

                {subtopic.examples && subtopic.examples.length > 0 && (
                  <div className="mb-4">
                    <h4 className="font-medium mb-2">Examples</h4>
                    <div className="space-y-3">
                      {subtopic.examples.map((example, idx) => (
                        <div key={idx} className="bg-gray-50 p-3 rounded">
                          <div className="font-medium">{example.title}</div>
                          <div className="text-sm text-gray-600">{example.description}</div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}

                {subtopic.exploreDeeper && subtopic.exploreDeeper.length > 0 && (
                  <div>
                    <h4 className="font-medium mb-2">Explore Deeper Paths</h4>
                    <div className="grid grid-cols-2 gap-4">
                      {subtopic.exploreDeeper.map((path, idx) => (
                        <button
                          key={idx}
                          onClick={() => handleExplorePathClick(path)}
                          disabled={isLoading}
                          className="text-left bg-gray-50 p-4 rounded hover:bg-gray-100 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                        >
                          <div className="font-medium mb-1">{path.title}</div>
                          <p className="text-sm text-gray-600 mb-2">{path.description}</p>
                          <div className="text-sm">
                            <div className="text-blue-600 mb-1">
                              <span className="font-medium">Key Concepts:</span> {path.concepts}
                            </div>
                            <div className="text-green-600 mb-1">
                              <span className="font-medium">Related Topics:</span> {path.relevantTopics}
                            </div>
                            <div className="text-purple-600">
                              <span className="font-medium">Research Areas:</span> {path.researchAreas}
                            </div>
                          </div>
                        </button>
                      ))}
                    </div>
                  </div>
                )}

                <button
                  className="mt-4 w-full p-3 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed"
                  onClick={() => handleSubtopicClick(subtopic)}
                  disabled={isLoading}
                >
                  Explore {subtopic.title}
                </button>
              </div>
            ))}
          </div>

          <h2 className="text-xl font-semibold mt-6 mb-3">Interdisciplinary Connections</h2>
          <div className="space-y-4">
            {currentTopic.connections.map((connection) => (
              <div key={connection.id} className="p-4 border rounded">
                <h3 className="font-semibold">{connection.title}</h3>
                <p>{connection.description}</p>
              </div>
            ))}
          </div>
        </div>
      ) : !isLoading && !error ? (
        <div className="flex-1 flex items-center justify-center text-gray-500">
          Enter a topic above to begin your exploration
        </div>
      ) : null}
    </div>
  );
}

================
File: src/components/Breadcrumbs.tsx
================
'use client';

import React from 'react';
import { Topic } from '@/types';

interface BreadcrumbsProps {
  path: Topic[];
  onNavigate: (topic: Topic) => void;
}

export default function Breadcrumbs({ path, onNavigate }: BreadcrumbsProps) {
  return (
    <nav className="flex flex-col space-y-2">
      <h2 className="text-lg font-semibold mb-2">Exploration Path</h2>
      <div className="flex flex-col space-y-1">
        {path.map((topic, index) => (
          <div 
            key={topic.id}
            className="flex items-center space-x-2"
          >
            <div className="flex-shrink-0 w-6 text-gray-400">
              {index + 1}.
            </div>
            <button
              onClick={() => onNavigate(topic)}
              className="text-left hover:text-blue-500 truncate"
            >
              {topic.title}
            </button>
          </div>
        ))}
      </div>
    </nav>
  );
}

================
File: src/components/ExplorationLayout.tsx
================
'use client';

import React from 'react';
import ExplorationTree from './ExplorationTree';
import Breadcrumbs from './Breadcrumbs';
import ExplorationStats from './ExplorationStats';
import { useExploration } from '@/context/ExplorationContext';

export default function ExplorationLayout({ children }: { children: React.ReactNode }) {
  const { explorationTree, currentTopic } = useExploration();

  return (
    <main className="flex h-screen">
      <aside className="w-1/4 border-r border-gray-200 p-4 overflow-hidden">
        <ExplorationTree data={explorationTree} />
      </aside>
      <section className="w-1/2 p-4">
        {children}
      </section>
      <aside className="w-1/4 border-l border-gray-200 p-4">
        <div className="space-y-8">
          <Breadcrumbs 
            path={currentTopic ? [currentTopic] : []} 
            onNavigate={() => {}} 
          />
          <ExplorationStats 
            currentTopic={currentTopic}
            pathLength={currentTopic ? 1 : 0}
            startTime={new Date()}
          />
        </div>
      </aside>
    </main>
  );
}

================
File: src/components/ExplorationStats.tsx
================
'use client';

import React from 'react';
import { Topic } from '@/types';

interface ExplorationStatsProps {
  currentTopic: Topic | null;
  pathLength: number;
  startTime: Date;
}

export default function ExplorationStats({ 
  currentTopic, 
  pathLength, 
  startTime 
}: ExplorationStatsProps) {
  const [elapsedTime, setElapsedTime] = React.useState<string>('00:00');

  React.useEffect(() => {
    const timer = setInterval(() => {
      const now = new Date();
      const diff = now.getTime() - startTime.getTime();
      const minutes = Math.floor(diff / 60000);
      const seconds = Math.floor((diff % 60000) / 1000);
      setElapsedTime(
        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`
      );
    }, 1000);

    return () => clearInterval(timer);
  }, [startTime]);

  return (
    <div className="space-y-6">
      <div>
        <h2 className="text-lg font-semibold mb-2">Session Stats</h2>
        <div className="space-y-2">
          <div className="flex justify-between">
            <span className="text-gray-500">Depth Level:</span>
            <span className="font-medium">{pathLength}</span>
          </div>
          <div className="flex justify-between">
            <span className="text-gray-500">Time Spent:</span>
            <span className="font-medium">{elapsedTime}</span>
          </div>
        </div>
      </div>

      {currentTopic && (
        <div>
          <h2 className="text-lg font-semibold mb-2">Current Topic</h2>
          <div className="text-sm text-gray-600">
            <p className="mb-2">
              <span className="font-medium">Depth:</span> {currentTopic.depth}
            </p>
            <p>
              <span className="font-medium">Subtopics:</span> {currentTopic.subtopics.length}
            </p>
          </div>
        </div>
      )}
    </div>
  );
}

================
File: src/components/ExplorationTree.tsx
================
'use client';

import React, { useEffect, useRef } from 'react';
import * as d3 from 'd3';
import { ExplorationNode } from '@/types';
import { HierarchyNode, HierarchyLink } from 'd3';

interface ExplorationTreeProps {
  data: ExplorationNode;
}

type D3Node = HierarchyNode<ExplorationNode>;
type D3Link = HierarchyLink<ExplorationNode>;

export default function ExplorationTree({ data }: ExplorationTreeProps) {
  const svgRef = useRef<SVGSVGElement>(null);

  useEffect(() => {
    if (!svgRef.current || !data) return;

    // Clear previous visualization
    d3.select(svgRef.current).selectAll('*').remove();

    const width = svgRef.current.clientWidth;
    const height = svgRef.current.clientHeight;
    const margin = { top: 40, right: 20, bottom: 40, left: 40 };

    // Create tree layout - swap width and height for vertical orientation
    const tree = d3.tree<ExplorationNode>()
      .size([width - margin.left - margin.right, height - margin.top - margin.bottom])
      .separation((a: D3Node, b: D3Node) => (a.parent === b.parent ? 1 : 1.5));

    // Create hierarchy from data
    const root = d3.hierarchy(data);
    const treeData = tree(root);

    // Create SVG container
    const svg = d3.select(svgRef.current)
      .attr('width', width)
      .attr('height', height);

    const g = svg.append('g')
      .attr('transform', `translate(${margin.left},${margin.top})`);

    // Create links with vertical path
    g.selectAll('.link')
      .data(treeData.links())
      .join('path')
      .attr('class', 'link')
      .attr('fill', 'none')
      .attr('stroke', '#ccc')
      .attr('stroke-width', 1.5)
      .attr('d', d3.linkVertical<D3Link, D3Link>()
        .x((d: any) => d.x)
        .y((d: any) => d.y)
      );

    // Create nodes with adjusted positioning
    const nodes = g.selectAll('.node')
      .data(treeData.descendants())
      .join('g')
      .attr('class', 'node')
      .attr('transform', (d: D3Node) => `translate(${d.x},${d.y})`);

    // Add circles to nodes
    nodes.append('circle')
      .attr('r', 6)
      .attr('fill', (d: D3Node) => d.data.depth === 0 ? '#4299e1' : '#9ae6b4')
      .attr('stroke', '#fff')
      .attr('stroke-width', 2);

    // Add labels to nodes with adjusted positioning
    nodes.append('text')
      .attr('dy', '1.5em')  // Position text below node
      .attr('x', 0)         // Center text horizontally
      .attr('text-anchor', 'middle')  // Center text alignment
      .text((d: D3Node) => d.data.title)
      .clone(true)
      .lower()
      .attr('stroke', 'white')
      .attr('stroke-width', 3);

  }, [data]);

  return (
    <div className="w-full h-full">
      <svg 
        ref={svgRef} 
        className="w-full h-full"
        style={{ minHeight: '600px' }}  // Increased height for better vertical display
      />
    </div>
  );
}

================
File: src/config/env.ts
================
export const env = {
  CLAUDE_API_KEY: process.env.CLAUDE_API_KEY as string,
  CLAUDE_API_URL: process.env.CLAUDE_API_URL as string,
} as const;

// Validate environment variables
if (!env.CLAUDE_API_KEY) {
  throw new Error('CLAUDE_API_KEY environment variable is not set');
}

if (!env.CLAUDE_API_URL) {
  throw new Error('CLAUDE_API_URL environment variable is not set');
}

================
File: src/context/ExplorationContext.tsx
================
'use client';

import React, { createContext, useContext, useState } from 'react';
import { Topic, ExplorationNode } from '@/types';

interface ExplorationContextType {
  currentTopic: Topic | null;
  explorationTree: ExplorationNode;
  setCurrentTopic: (topic: Topic | null) => void;
  addToExploration: (parentId: string, topic: Topic) => void;
}

const ExplorationContext = createContext<ExplorationContextType | undefined>(undefined);

export function ExplorationProvider({ children }: { children: React.ReactNode }) {
  const [currentTopic, setCurrentTopic] = useState<Topic | null>(null);
  const [explorationTree, setExplorationTree] = useState<ExplorationNode>({
    id: 'root',
    title: 'Start Exploring',
    children: [],
    depth: 0
  });

  const addToExploration = (parentId: string, topic: Topic) => {
    const newNode: ExplorationNode = {
      id: topic.id,
      title: topic.title,
      children: [],
      depth: topic.depth
    };

    setExplorationTree((prevTree: ExplorationNode) => {
      const updateChildren = (node: ExplorationNode): ExplorationNode => {
        if (node.id === parentId) {
          return {
            ...node,
            children: [...node.children, newNode]
          };
        }
        return {
          ...node,
          children: node.children.map(updateChildren)
        };
      };
      return updateChildren(prevTree);
    });
  };

  return (
    <ExplorationContext.Provider 
      value={{ 
        currentTopic, 
        explorationTree, 
        setCurrentTopic, 
        addToExploration 
      }}
    >
      {children}
    </ExplorationContext.Provider>
  );
}

export function useExploration() {
  const context = useContext(ExplorationContext);
  if (context === undefined) {
    throw new Error('useExploration must be used within an ExplorationProvider');
  }
  return context;
}

================
File: src/lib/claude.ts
================
import { env } from '@/config/env';
import { parseStringPromise } from 'xml2js';

interface ClaudeResponse {
  id: string;
  type: string;
  role: string;
  content: Array<{
    type: string;
    text: string;
  }>;
  model: string;
  stop_reason: string | null;
  usage: {
    input_tokens: number;
    output_tokens: number;
  };
}

export async function generateTopicExploration(topic: string, parentContext: string = '') {
  try {
    // Log environment configuration
    console.log('Environment Check:', {
      apiKeyPresent: !!env.CLAUDE_API_KEY,
      apiKeyLength: env.CLAUDE_API_KEY?.length || 0,
    });

    console.log('Making request to Claude API for topic:', topic);
    const requestBody = {
      model: 'claude-3-5-haiku-20241022',
      max_tokens: 5000,
      temperature: 0.9,
      system: "You are an expert knowledge exploration assistant. Your task is to help users explore topics in depth. Always respond in well-structured XML format. Focus on generating detailed subtopics with multiple explore deeper paths.",
      messages: [{
        role: 'user',
        content: `Generate a comprehensive exploration of the topic "${topic}". Include:

1. A thorough summary (4-5 paragraphs) that covers:
   - Core concepts and fundamental principles
   - Historical context and development
   - Current significance and applications
   - Key challenges and ongoing debates
   - Future implications and trends

2. 10-12 relevant subtopics with detailed descriptions that include:
   - Key concepts and terminology
   - Real-world examples and case studies
   - Common misconceptions
   - Latest developments or research
   - 5-6 explore deeper paths for each subtopic, including:
     * Related advanced concepts
     * Specialized areas of study
     * Current research directions
     * Emerging technologies or methodologies
     * Controversial aspects or debates
     * Historical developments and evolution

Format your response in this exact XML structure:
<exploration>
  <summary>Comprehensive summary addressing all required points</summary>
  <subtopics>
    <topic>
      <title>Subtopic title</title>
      <description>Detailed description including examples and case studies</description>
      <keyTerms>
        <term>
          <name>Technical term</name>
          <definition>Clear definition with examples</definition>
        </term>
      </keyTerms>
      <examples>
        <example>
          <title>Example title</title>
          <description>Detailed example description</description>
        </example>
      </examples>
      <exploreDeeper>
        <path>
          <title>Advanced Concepts Path</title>
          <description>Exploration of advanced theoretical frameworks and concepts</description>
          <concepts>Key advanced concepts to explore</concepts>
          <relevantTopics>Advanced theoretical areas</relevantTopics>
          <researchAreas>Theoretical research directions</researchAreas>
        </path>
        <path>
          <title>Research Directions Path</title>
          <description>Current and emerging research directions in the field</description>
          <concepts>Research methodologies and approaches</concepts>
          <relevantTopics>Current research topics</relevantTopics>
          <researchAreas>Active research areas and opportunities</researchAreas>
        </path>
        <path>
          <title>Technological Applications Path</title>
          <description>Practical applications and technological implementations</description>
          <concepts>Applied concepts and technologies</concepts>
          <relevantTopics>Implementation areas</relevantTopics>
          <researchAreas>Technology development directions</researchAreas>
        </path>
        <path>
          <title>Historical Development Path</title>
          <description>Evolution and historical significance of key developments</description>
          <concepts>Historical frameworks and paradigms</concepts>
          <relevantTopics>Historical context and evolution</relevantTopics>
          <researchAreas>Historical analysis methods</researchAreas>
        </path>
        <path>
          <title>Controversies and Debates Path</title>
          <description>Major debates and controversial aspects in the field</description>
          <concepts>Competing theories and viewpoints</concepts>
          <relevantTopics>Controversial areas and debates</relevantTopics>
          <researchAreas>Critical analysis approaches</researchAreas>
        </path>
        <path>
          <title>Future Directions Path</title>
          <description>Emerging trends and future possibilities</description>
          <concepts>Future scenarios and possibilities</concepts>
          <relevantTopics>Emerging trends and developments</relevantTopics>
          <researchAreas>Future-oriented research</researchAreas>
        </path>
      </exploreDeeper>
    </topic>
  </subtopics>
  <context>
    <historical>
      <evolution>Historical evolution and key developments</evolution>
      <keyEvents>
        <event>
          <date>Date or period</date>
          <description>Event description and significance</description>
        </event>
      </keyEvents>
    </historical>
    <current>
      <state>Current state of the field</state>
      <trends>Emerging trends and developments</trends>
      <challenges>Current challenges and obstacles</challenges>
    </current>
    <cultural>
      <perspectives>Different viewpoints and interpretations</perspectives>
      <impact>Societal and cultural implications</impact>
    </cultural>
  </context>
</exploration>

Important: 
- Ensure your response is valid XML and follows this exact structure
- MUST include all 6 explore deeper paths for each subtopic as shown in the example
- Each explore deeper path should focus on a different aspect (advanced concepts, research, technology, history, controversies, future)
- Provide specific, concrete examples rather than general statements
- Include recent developments and cutting-edge research
- Balance technical depth with accessibility
- Make sure explore deeper paths are substantive and lead to meaningful areas of further study
- Include comprehensive analysis in the summary and context sections`
      }]
    };

    console.log('Claude API Request:', {
      url: 'https://api.anthropic.com/v1/messages',
      headers: {
        'Content-Type': 'application/json',
        'anthropic-version': '2023-06-01'
      },
      body: requestBody
    });

    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'anthropic-version': '2023-06-01',
        'x-api-key': env.CLAUDE_API_KEY
      },
      body: JSON.stringify(requestBody)
    });

    console.log('Claude API Response Status:', response.status);
    console.log('Claude API Response Headers:', Object.fromEntries(response.headers.entries()));

    if (!response.ok) {
      let errorMessage = `Claude API call failed: ${response.statusText}`;
      try {
        const responseText = await response.text();
        console.error('Claude API Error Response:', responseText);
        try {
          const errorData = JSON.parse(responseText);
          console.error('Claude API Error Data:', errorData);
          errorMessage = errorData.error?.message || errorMessage;
        } catch (parseError) {
          console.error('Failed to parse error response as JSON:', parseError);
        }
      } catch (e) {
        console.error('Failed to read error response:', e);
      }
      throw new Error(errorMessage);
    }

    // Read the response as text first
    const responseText = await response.text();
    console.log('Claude API Raw Response:', responseText);

    // Log the full response text for debugging
    console.log('Full API Response Text:', responseText);

    // Check if the response is JSON and log it
    try {
      const jsonResponse = JSON.parse(responseText);
      console.log('Parsed JSON Response:', jsonResponse);
    } catch (jsonParseError) {
      console.error('Response is not valid JSON:', jsonParseError);
    }

    // Then parse as JSON
    const data: ClaudeResponse = JSON.parse(responseText);
    
    if (!data.content?.[0]?.text) {
      console.error('Unexpected Claude API response format:', data);
      throw new Error('Invalid response format from Claude API');
    }

    const xmlContent = data.content[0].text;
    console.log('Claude API XML Response:', xmlContent);

    // Extract the XML content from the response
    const xmlMatch = xmlContent.match(/<exploration>[\s\S]*<\/exploration>/);
    if (!xmlMatch) {
      console.error('No XML found in response:', xmlContent);
      throw new Error('No XML found in Claude response');
    }

    const cleanXml = xmlMatch[0].trim();
    console.log('Cleaned XML:', cleanXml);

    return parseClaudeResponse(cleanXml);
  } catch (error) {
    console.error('Error in generateTopicExploration:', {
      name: error instanceof Error ? error.name : 'Unknown',
      message: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : 'No stack trace',
      error
    });
    throw error;
  }
}

async function parseClaudeResponse(xmlContent: string) {
  try {
    console.log('Attempting to parse XML:', xmlContent);

    // Parse XML with explicit array handling for paths
    const result = await parseStringPromise(xmlContent, { 
      explicitArray: true,  // Changed to true to force arrays
      mergeAttrs: true 
    });

    console.log('Parsed XML Result:', result);

    if (!result.exploration || !result.exploration.summary || !result.exploration.subtopics) {
      throw new Error('Invalid XML structure: missing required elements');
    }

    const summary = result.exploration.summary[0];
    
    // Parse subtopics with enhanced structure
    const subtopics = result.exploration.subtopics[0]?.topic?.map((t: any) => {
      console.log('Processing subtopic:', t.title?.[0]);
      
      // Get all paths from the exploreDeeper section
      const paths = t.exploreDeeper?.[0]?.path || [];
      console.log(`Found ${paths.length} explore deeper paths for subtopic ${t.title?.[0]}`);
      
      return {
        title: t.title?.[0] || '',
        description: t.description?.[0] || '',
        keyTerms: t.keyTerms?.[0]?.term?.map((term: any) => ({
          name: term.name?.[0] || '',
          definition: term.definition?.[0] || ''
        })) || [],
        examples: t.examples?.[0]?.example?.map((ex: any) => ({
          title: ex.title?.[0] || '',
          description: ex.description?.[0] || ''
        })) || [],
        exploreDeeper: paths.map((p: any) => ({
          title: p.title?.[0] || '',
          description: p.description?.[0] || '',
          concepts: p.concepts?.[0] || '',
          relevantTopics: p.relevantTopics?.[0] || '',
          researchAreas: p.researchAreas?.[0] || ''
        }))
      };
    }) || [];

    // Parse connections
    const connections = result.exploration.connections?.[0]?.connection?.map((c: any) => ({
      title: c.title?.[0] || '',
      description: c.description?.[0] || ''
    })) || [];

    const parsedData = {
      summary,
      subtopics,
      connections
    };

    console.log('Successfully parsed response:', parsedData);
    return parsedData;
  } catch (error) {
    console.error('Error parsing XML response:', {
      error,
      xmlContent,
      errorName: error instanceof Error ? error.name : 'Unknown',
      errorMessage: error instanceof Error ? error.message : String(error),
      errorStack: error instanceof Error ? error.stack : 'No stack trace',
    });
    throw new Error('Failed to parse Claude response');
  }
}

================
File: src/types/css.d.ts
================
declare module '*.css' {
  const styles: { [className: string]: string }
  export default styles
}

declare module 'postcss' {
  export interface AtRule {
    name: string;
    params: string;
  }
}

// Add support for CSS Modules
declare module '*.module.css' {
  const classes: { [key: string]: string }
  export default classes
}

// Add support for Tailwind directives
interface TailwindDirective {
  (path: string): void
}

declare module 'tailwindcss' {
  const tailwind: TailwindDirective
  export default tailwind
}

declare module 'autoprefixer' {
  const autoprefixer: any;
  export default autoprefixer;
}

================
File: src/types/index.ts
================
export interface Topic {
  id: string;
  title: string;
  summary: string;
  subtopics: SubTopic[];
  connections: Connection[];
  parentId?: string;
  depth: number;
}

export interface SubTopic {
  id: string;
  title: string;
  description: string;
  keyTerms: Array<{
    name: string;
    definition: string;
  }>;
  examples: Array<{
    title: string;
    description: string;
  }>;
  exploreDeeper: Array<{
    title: string;
    description: string;
    concepts: string;
    relevantTopics: string;
    researchAreas: string;
  }>;
}

export interface Connection {
  id: string;
  title: string;
  description: string;
}

export interface ExplorationNode {
  id: string;
  title: string;
  children: ExplorationNode[];
  depth: number;
}

================
File: src/env.d.ts
================
/// <reference types="next" />
/// <reference types="next/image-types/global" />

declare namespace NodeJS {
  interface ProcessEnv {
    NEXT_PUBLIC_CLAUDE_API_KEY: string;
    NODE_ENV: 'development' | 'production' | 'test';
  }
}

declare module '*.css' {
  const content: { [className: string]: string };
  export default content;
}

declare namespace JSX {
  interface IntrinsicElements {
    [elemName: string]: any;
  }
}

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

================
File: next.config.js
================
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
}

module.exports = nextConfig

================
File: package.json
================
{
  "name": "rabbit-hole",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@types/xml2js": "^0.4.14",
    "d3": "7.9.0",
    "jsdom": "^26.0.0",
    "next": "14.1.0",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "uuid": "9.0.1",
    "xml2js": "^0.6.2"
  },
  "devDependencies": {
    "@types/d3": "7.4.3",
    "@types/jsdom": "^21.1.7",
    "@types/node": "20.11.0",
    "@types/react": "18.2.0",
    "@types/react-dom": "18.2.0",
    "@types/uuid": "9.0.7",
    "autoprefixer": "10.4.17",
    "eslint": "8.56.0",
    "eslint-config-next": "14.1.0",
    "postcss": "8.4.33",
    "tailwindcss": "3.4.1",
    "typescript": "5.3.3"
  }
}

================
File: postcss.config.js
================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================
File: tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}

================
File: terminal
================
cd ..
rm -rf rabbit-hole    # Remove the nested directory
rm -rf node_modules package-lock.json
npm install next@14.1.0 react@18.2.0 react-dom@18.2.0
npm install --save-dev typescript@5.3.3 @types/node@20.11.0 @types/react@18.2.0 @types/react-dom@18.2.0 @types/uuid@9.0.7 @types/d3@7.4.3
npm install d3@7.9.0 uuid@9.0.1
npm install react @types/react react-dom @types/react-dom --save
cat package.json | cat
pwd
ls node_modules/next/types
npm run dev

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
