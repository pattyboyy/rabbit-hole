This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-28T05:52:00.781Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Directory Structure
================================================================
src/
  app/
    api/
      explore/
        route.ts
    globals.css
    layout.tsx
    page.tsx
  components/
    Breadcrumbs.tsx
    ExplorationLayout.tsx
    ExplorationStats.tsx
    ExplorationTree.tsx
    LoadingSpinner.tsx
  config/
    env.ts
  context/
    ExplorationContext.tsx
  lib/
    claude.ts
    loadingStates.ts
  types/
    css.d.ts
    index.ts
  env.d.ts
.gitignore
next.config.js
package.json
postcss.config.js
tailwind.config.js
terminal
tsconfig.json

================================================================
Files
================================================================

================
File: src/app/api/explore/route.ts
================
import { NextRequest } from 'next/server';
import { generateTopicExploration } from '@/lib/claude';
import { loadingMessages } from '@/lib/loadingStates';

// Assuming the structure of subtopics and connections
interface Subtopic {
  id: string;
  title: string;
  description: string;
  keyTerms: Array<{
    name: string;
    definition: string;
  }>;
  examples: Array<{
    title: string;
    description: string;
  }>;
}

interface Connection {
  id: string;
  title: string;
  description: string;
  examples: string[];
  research: string;
}

interface Context {
  historical: {
    evolution: string;
    keyEvents: Array<{
      date: string;
      description: string;
    }>;
  };
  current: {
    state: string;
    trends: string;
    challenges: string;
  };
  cultural: {
    perspectives: string;
    impact: string;
  };
}

interface ExpertOpinion {
  id: string;
  expert: string;
  quote: string;
  context: string;
  source: string;
}

interface Application {
  id: string;
  title: string;
  description: string;
  caseStudy: string;
  challenges: string;
  solutions: string;
}

export async function POST(request: NextRequest) {
  console.log('API route called');
  
  try {
    const body = await request.json();
    console.log('Request body:', body);

    const { topic, parentId, depth } = body;

    // Create encoder for sending events
    const encoder = new TextEncoder();

    // Create a transform stream with proper error handling
    const stream = new TransformStream({
      transform(chunk, controller) {
        controller.enqueue(chunk);
      },
      flush(controller) {
        controller.terminate();
      }
    });

    const writer = stream.writable.getWriter();

    // Function to send SSE messages with proper formatting
    const sendEvent = async (type: string, data: any) => {
      const event = `data: ${JSON.stringify({ type, ...data })}\n\n`;
      console.log('Sending event:', event.trim());
      await writer.write(encoder.encode(event));
    };

    // Create the response with appropriate headers
    const response = new Response(stream.readable, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache, no-transform',
        'Connection': 'keep-alive',
        'X-Accel-Buffering': 'no'
      },
    });

    // Start the exploration process
    try {
      console.log('Starting exploration for:', topic);
      
      const result = await generateTopicExploration(
        topic,
        parentId,
        async (message: string, progress: number) => {
          console.log('Progress update:', message, progress);
          await sendEvent('progress', { message, progress });
        }
      );

      console.log('Exploration complete, sending result');
      await sendEvent('complete', {
        data: {
          ...result,
          id: Math.random().toString(36).substring(7),
          title: topic,
          parentId,
          depth: depth || 0,
        }
      });

    } catch (error) {
      console.error('Exploration error:', error);
      await sendEvent('error', {
        message: error instanceof Error ? error.message : 'An error occurred during exploration'
      });
    } finally {
      // Ensure the stream is properly closed
      try {
        await writer.close();
      } catch (e) {
        console.error('Error closing stream:', e);
      }
    }

    console.log('Stream closed');
    return response;

  } catch (error) {
    console.error('API route error:', error);
    return new Response(
      JSON.stringify({ 
        error: error instanceof Error ? error.message : 'An error occurred'
      }),
      { 
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      }
    );
  }
}

================
File: src/app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0;
  --background-rgb: 255, 255, 255;
}

body {
  color: rgb(var(--foreground-rgb));
  background: rgb(var(--background-rgb));
}

================
File: src/app/layout.tsx
================
import React from 'react';
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import { ExplorationProvider } from '@/context/ExplorationContext';
import ExplorationLayout from '@/components/ExplorationLayout';

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Rabbit Hole - Knowledge Exploration Platform",
  description: "Infinitely explore any topic through AI-generated layers",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className={inter.className} suppressHydrationWarning>
        <ExplorationProvider>
          <ExplorationLayout>
            {children}
          </ExplorationLayout>
        </ExplorationProvider>
      </body>
    </html>
  );
}

================
File: src/app/page.tsx
================
'use client';

import React, { useState, useEffect } from 'react';
import { Topic, ExplorePath } from '@/types';
import { useExploration } from '@/context/ExplorationContext';
import { LoadingSpinner } from '@/components/LoadingSpinner';
import { LoadingState, defaultLoadingState } from '@/lib/loadingStates';

export default function Home() {
  const [searchTerm, setSearchTerm] = useState('');
  const [currentTopic, setCurrentTopic] = useState<Topic | null>(null);
  const [loadingState, setLoadingState] = useState<LoadingState>(defaultLoadingState);
  const [error, setError] = useState<string | null>(null);
  const { addToExploration } = useExploration();

  const handleSearch = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (!searchTerm.trim()) return;

    // Reset states
    setCurrentTopic(null);
    setError(null);
    setLoadingState({ isLoading: true, message: 'Starting exploration...', progress: 0 });

    try {
      const response = await fetch('/api/explore', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ 
          topic: searchTerm.trim(),
          depth: 0
        }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('API Error:', errorText);
        throw new Error(`API request failed: ${response.statusText}`);
      }

      const reader = response.body?.getReader();
      if (!reader) {
        throw new Error('No response stream available');
      }

      const decoder = new TextDecoder();
      let buffer = '';

      while (true) {
        const { done, value } = await reader.read();
        
        if (done) {
          console.log('Stream complete');
          break;
        }

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          if (line.trim() === '') continue;
          if (line.startsWith('data: ')) {
            try {
              const data = JSON.parse(line.slice(5));
              console.log('Received event:', data);

              if (data.type === 'progress') {
                setLoadingState(prevState => ({
                  ...prevState,
                  isLoading: true,
                  message: data.message,
                  progress: data.progress
                }));
              } else if (data.type === 'complete') {
                console.log('Setting current topic:', data.data);
                const topicData = {
                  ...data.data,
                  explorePaths: data.data.explorePaths.map((path: any) => ({
                    ...path,
                    relevantTopics: path.relevantTopics || 'None specified',
                    researchAreas: path.researchAreas || 'None specified'
                  }))
                };
                setCurrentTopic(topicData);
                addToExploration('root', topicData);
                setLoadingState({
                  isLoading: false,
                  message: '',
                  progress: 0
                });
              } else if (data.type === 'error') {
                throw new Error(data.message);
              }
            } catch (e) {
              console.error('Error parsing SSE data:', e, 'Line:', line);
            }
          }
        }
      }
    } catch (error) {
      console.error('Search error:', error);
      setError(error instanceof Error ? error.message : 'Failed to fetch topic');
      setLoadingState({
        isLoading: false,
        message: '',
        progress: 0
      });
    }
  };

  const handleSubtopicClick = async (subtopic: { id: string; title: string }) => {
    if (!currentTopic) return;
    
    setError(null);
    setLoadingState({ isLoading: true, message: 'Starting exploration...', progress: 0 });

    try {
      const response = await fetch('/api/explore', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          topic: subtopic.title,
          parentId: currentTopic.id,
          depth: currentTopic.depth + 1
        }),
      });

      if (!response.body) {
        throw new Error('No response stream available');
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = decoder.decode(value);
        const lines = chunk.split('\n');

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            try {
              const data = JSON.parse(line.slice(5));
              
              if (data.type === 'progress') {
                setLoadingState({
                  isLoading: true,
                  message: data.message,
                  progress: data.progress
                });
              } else if (data.type === 'complete') {
                setCurrentTopic(data.data);
                addToExploration(currentTopic.id, data.data);
                setLoadingState({
                  isLoading: false,
                  message: 'Exploration complete!',
                  progress: 100
                });
              } else if (data.type === 'error') {
                throw new Error(data.message);
              }
            } catch (e) {
              console.error('Error parsing SSE data:', e);
            }
          }
        }
      }
    } catch (error) {
      console.error('Error fetching subtopic:', error);
      setError(error instanceof Error ? error.message : 'Failed to fetch subtopic');
      setLoadingState({
        isLoading: false,
        message: 'Error occurred',
        progress: 0
      });
    }
  };

  const handleExplorePathClick = async (path: ExplorePath) => {
    if (!currentTopic) return;
    
    setError(null);
    setLoadingState({ isLoading: true, message: 'Starting exploration...', progress: 0 });

    try {
      const response = await fetch('/api/explore', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          topic: path.title,
          parentId: currentTopic.id,
          depth: currentTopic.depth + 1,
          context: path.description
        }),
      });

      if (!response.body) {
        throw new Error('No response stream available');
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = decoder.decode(value);
        const lines = chunk.split('\n');

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            try {
              const data = JSON.parse(line.slice(5));
              
              if (data.type === 'progress') {
                setLoadingState({
                  isLoading: true,
                  message: data.message,
                  progress: data.progress
                });
              } else if (data.type === 'complete') {
                setCurrentTopic(data.data);
                addToExploration(currentTopic.id, data.data);
                setLoadingState({
                  isLoading: false,
                  message: 'Exploration complete!',
                  progress: 100
                });
              } else if (data.type === 'error') {
                throw new Error(data.message);
              }
            } catch (e) {
              console.error('Error parsing SSE data:', e);
            }
          }
        }
      }
    } catch (error) {
      console.error('Error fetching path:', error);
      setError(error instanceof Error ? error.message : 'Failed to fetch path');
      setLoadingState({
        isLoading: false,
        message: 'Error occurred',
        progress: 0
      });
    }
  };

  return (
    <div className="h-full flex flex-col gap-4 p-4">
      <form onSubmit={handleSearch} className="flex gap-2">
        <input
          type="text"
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          placeholder="Enter a topic to explore..."
          className="flex-1 p-2 border rounded"
          disabled={loadingState.isLoading}
        />
        <button 
          type="submit"
          className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed"
          disabled={loadingState.isLoading || !searchTerm.trim()}
        >
          {loadingState.isLoading ? <LoadingSpinner size="small" /> : 'Explore'}
        </button>
      </form>

      {loadingState.isLoading && (
        <div className="my-8">
          <LoadingSpinner size="large" message={loadingState.message} />
          <div className="mt-4">
            <div className="w-full bg-gray-200 rounded-full h-2.5">
              <div 
                className="bg-blue-500 h-2.5 rounded-full transition-all duration-300 ease-in-out"
                style={{ width: `${loadingState.progress}%` }}
              />
            </div>
            <div className="text-center text-sm text-gray-500 mt-2">
              {loadingState.progress}%
            </div>
          </div>
        </div>
      )}

      {error && !loadingState.isLoading && (
        <div className="p-4 bg-red-50 border border-red-200 rounded text-red-600">
          {error}
        </div>
      )}

      {currentTopic && !loadingState.isLoading && (
        <div key={currentTopic.id} className="flex-1 overflow-y-auto">
          <h1 className="text-2xl font-bold mb-4">{currentTopic.title}</h1>
          <p className="mb-6 text-gray-700">{currentTopic.summary}</p>
          
          <h2 className="text-xl font-semibold mb-3">Explore Deeper</h2>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {currentTopic.explorePaths.map((path, idx) => (
              <div key={`${currentTopic.id}-${idx}`} className="border rounded-lg p-6 bg-white shadow-sm hover:shadow-md transition-shadow">
                <h3 className="text-lg font-semibold mb-2">{path.title}</h3>
                <p className="text-gray-600 mb-4">{path.description}</p>
                
                <div className="space-y-4">
                  <div>
                    <h4 className="font-medium text-gray-700">Key Concepts</h4>
                    <div className="bg-gray-50 p-3 rounded mt-1">
                      <p className="text-sm text-gray-600">{path.concepts}</p>
                    </div>
                  </div>

                  <div>
                    <h4 className="font-medium text-gray-700">Relevant Topics</h4>
                    <div className="bg-gray-50 p-3 rounded mt-1">
                      <p className="text-sm text-gray-600">{path.relevantTopics}</p>
                    </div>
                  </div>

                  <div>
                    <h4 className="font-medium text-gray-700">Research Areas</h4>
                    <div className="bg-gray-50 p-3 rounded mt-1">
                      <p className="text-sm text-gray-600">{path.researchAreas}</p>
                    </div>
                  </div>
                </div>

                <button
                  onClick={() => handleExplorePathClick(path)}
                  disabled={loadingState.isLoading}
                  className="w-full mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  Explore This Path
                </button>
              </div>
            ))}
          </div>
        </div>
      )}

      {!currentTopic && !loadingState.isLoading && !error && (
        <div className="flex-1 flex items-center justify-center text-gray-500">
          Enter a topic above to begin your exploration
        </div>
      )}
    </div>
  );
}

================
File: src/components/Breadcrumbs.tsx
================
'use client';

import React from 'react';
import { Topic } from '@/types';

interface BreadcrumbsProps {
  path: Topic[];
  onNavigate: (topic: Topic) => void;
}

export default function Breadcrumbs({ path, onNavigate }: BreadcrumbsProps) {
  return (
    <nav className="flex flex-col space-y-2">
      <h2 className="text-lg font-semibold mb-2">Exploration Path</h2>
      <div className="flex flex-col space-y-1">
        {path.map((topic, index) => (
          <div 
            key={topic.id}
            className="flex items-center space-x-2"
          >
            <div className="flex-shrink-0 w-6 text-gray-400">
              {index + 1}.
            </div>
            <button
              onClick={() => onNavigate(topic)}
              className="text-left hover:text-blue-500 truncate"
            >
              {topic.title}
            </button>
          </div>
        ))}
      </div>
    </nav>
  );
}

================
File: src/components/ExplorationLayout.tsx
================
'use client';

import React from 'react';
import ExplorationTree from './ExplorationTree';
import Breadcrumbs from './Breadcrumbs';
import ExplorationStats from './ExplorationStats';
import { useExploration } from '@/context/ExplorationContext';

export default function ExplorationLayout({ children }: { children: React.ReactNode }) {
  const { explorationTree, currentTopic } = useExploration();

  return (
    <main className="flex h-screen">
      <aside className="w-1/4 border-r border-gray-200 p-4 overflow-hidden">
        <ExplorationTree data={explorationTree} />
      </aside>
      <section className="w-1/2 p-4">
        {children}
      </section>
      <aside className="w-1/4 border-l border-gray-200 p-4">
        <div className="space-y-8">
          <Breadcrumbs 
            path={currentTopic ? [currentTopic] : []} 
            onNavigate={() => {}} 
          />
          <ExplorationStats 
            currentTopic={currentTopic}
            pathLength={currentTopic ? 1 : 0}
            startTime={new Date()}
          />
        </div>
      </aside>
    </main>
  );
}

================
File: src/components/ExplorationStats.tsx
================
'use client';

import React from 'react';
import { Topic } from '@/types';

interface ExplorationStatsProps {
  currentTopic: Topic | null;
  pathLength: number;
  startTime: Date;
}

export default function ExplorationStats({ 
  currentTopic, 
  pathLength, 
  startTime 
}: ExplorationStatsProps) {
  const [elapsedTime, setElapsedTime] = React.useState<string>('00:00');

  React.useEffect(() => {
    const timer = setInterval(() => {
      const now = new Date();
      const diff = now.getTime() - startTime.getTime();
      const minutes = Math.floor(diff / 60000);
      const seconds = Math.floor((diff % 60000) / 1000);
      setElapsedTime(
        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`
      );
    }, 1000);

    return () => clearInterval(timer);
  }, [startTime]);

  return (
    <div className="space-y-6">
      <div>
        <h2 className="text-lg font-semibold mb-2">Session Stats</h2>
        <div className="space-y-2">
          <div className="flex justify-between">
            <span className="text-gray-500">Depth Level:</span>
            <span className="font-medium">{pathLength}</span>
          </div>
          <div className="flex justify-between">
            <span className="text-gray-500">Time Spent:</span>
            <span className="font-medium">{elapsedTime}</span>
          </div>
        </div>
      </div>

      {currentTopic && (
        <div>
          <h2 className="text-lg font-semibold mb-2">Current Topic</h2>
          <div className="text-sm text-gray-600">
            <p className="mb-2">
              <span className="font-medium">Depth:</span> {currentTopic.depth}
            </p>
            <p>
              <span className="font-medium">Explore Paths:</span> {currentTopic.explorePaths.length}
            </p>
          </div>
        </div>
      )}
    </div>
  );
}

================
File: src/components/ExplorationTree.tsx
================
'use client';

import React, { useEffect, useRef } from 'react';
import * as d3 from 'd3';
import { ExplorationNode } from '@/types';
import { HierarchyNode, HierarchyLink } from 'd3';

interface ExplorationTreeProps {
  data: ExplorationNode;
}

type D3Node = HierarchyNode<ExplorationNode>;
type D3Link = HierarchyLink<ExplorationNode>;

export default function ExplorationTree({ data }: ExplorationTreeProps) {
  const svgRef = useRef<SVGSVGElement>(null);

  useEffect(() => {
    if (!svgRef.current || !data) return;

    // Clear previous visualization
    d3.select(svgRef.current).selectAll('*').remove();

    const width = svgRef.current.clientWidth;
    const height = svgRef.current.clientHeight;
    const margin = { top: 40, right: 20, bottom: 40, left: 40 };

    // Create tree layout - swap width and height for vertical orientation
    const tree = d3.tree<ExplorationNode>()
      .size([width - margin.left - margin.right, height - margin.top - margin.bottom])
      .separation((a: D3Node, b: D3Node) => (a.parent === b.parent ? 1 : 1.5));

    // Create hierarchy from data
    const root = d3.hierarchy(data);
    const treeData = tree(root);

    // Create SVG container
    const svg = d3.select(svgRef.current)
      .attr('width', width)
      .attr('height', height);

    const g = svg.append('g')
      .attr('transform', `translate(${margin.left},${margin.top})`);

    // Create links with vertical path
    g.selectAll('.link')
      .data(treeData.links())
      .join('path')
      .attr('class', 'link')
      .attr('fill', 'none')
      .attr('stroke', '#ccc')
      .attr('stroke-width', 1.5)
      .attr('d', d3.linkVertical<D3Link, D3Link>()
        .x((d: any) => d.x)
        .y((d: any) => d.y)
      );

    // Create nodes with adjusted positioning
    const nodes = g.selectAll('.node')
      .data(treeData.descendants())
      .join('g')
      .attr('class', 'node')
      .attr('transform', (d: D3Node) => `translate(${d.x},${d.y})`);

    // Add circles to nodes
    nodes.append('circle')
      .attr('r', 6)
      .attr('fill', (d: D3Node) => d.data.depth === 0 ? '#4299e1' : '#9ae6b4')
      .attr('stroke', '#fff')
      .attr('stroke-width', 2);

    // Add labels to nodes with adjusted positioning
    nodes.append('text')
      .attr('dy', '1.5em')  // Position text below node
      .attr('x', 0)         // Center text horizontally
      .attr('text-anchor', 'middle')  // Center text alignment
      .text((d: D3Node) => d.data.title)
      .clone(true)
      .lower()
      .attr('stroke', 'white')
      .attr('stroke-width', 3);

  }, [data]);

  return (
    <div className="w-full h-full">
      <svg 
        ref={svgRef} 
        className="w-full h-full"
        style={{ minHeight: '600px' }}  // Increased height for better vertical display
      />
    </div>
  );
}

================
File: src/components/LoadingSpinner.tsx
================
import React from 'react';

interface LoadingSpinnerProps {
  size?: 'small' | 'medium' | 'large';
  message?: string;
}

export function LoadingSpinner({ size = 'medium', message = 'Exploring topic...' }: LoadingSpinnerProps) {
  const sizeClasses = {
    small: 'w-4 h-4',
    medium: 'w-8 h-8',
    large: 'w-12 h-12'
  };

  return (
    <div className="flex flex-col items-center justify-center space-y-4 p-4">
      <div className={`${sizeClasses[size]} animate-spin`}>
        <div className="h-full w-full rounded-full border-4 border-gray-200 border-t-blue-500"></div>
      </div>
      {message && (
        <div className="text-gray-600 text-sm animate-pulse">
          {message}
        </div>
      )}
    </div>
  );
}

================
File: src/config/env.ts
================
export const env = {
  CLAUDE_API_KEY: process.env.CLAUDE_API_KEY as string,
  CLAUDE_API_URL: process.env.CLAUDE_API_URL as string,
} as const;

// Validate environment variables
if (!env.CLAUDE_API_KEY) {
  throw new Error('CLAUDE_API_KEY environment variable is not set');
}

if (!env.CLAUDE_API_URL) {
  throw new Error('CLAUDE_API_URL environment variable is not set');
}

================
File: src/context/ExplorationContext.tsx
================
'use client';

import React, { createContext, useContext, useState } from 'react';
import { Topic, ExplorationNode } from '@/types';

interface ExplorationContextType {
  currentTopic: Topic | null;
  explorationTree: ExplorationNode;
  setCurrentTopic: (topic: Topic | null) => void;
  addToExploration: (parentId: string, topic: Topic) => void;
}

const ExplorationContext = createContext<ExplorationContextType | undefined>(undefined);

export function ExplorationProvider({ children }: { children: React.ReactNode }) {
  const [currentTopic, setCurrentTopic] = useState<Topic | null>(null);
  const [explorationTree, setExplorationTree] = useState<ExplorationNode>({
    id: 'root',
    title: 'Start Exploring',
    children: [],
    depth: 0
  });

  const addToExploration = (parentId: string, topic: Topic) => {
    const newNode: ExplorationNode = {
      id: topic.id,
      title: topic.title,
      children: [],
      depth: topic.depth
    };

    setExplorationTree((prevTree: ExplorationNode) => {
      const updateChildren = (node: ExplorationNode): ExplorationNode => {
        if (node.id === parentId) {
          return {
            ...node,
            children: [...node.children, newNode]
          };
        }
        return {
          ...node,
          children: node.children.map(updateChildren)
        };
      };
      return updateChildren(prevTree);
    });
  };

  return (
    <ExplorationContext.Provider 
      value={{ 
        currentTopic, 
        explorationTree, 
        setCurrentTopic, 
        addToExploration 
      }}
    >
      {children}
    </ExplorationContext.Provider>
  );
}

export function useExploration() {
  const context = useContext(ExplorationContext);
  if (context === undefined) {
    throw new Error('useExploration must be used within an ExplorationProvider');
  }
  return context;
}

================
File: src/lib/claude.ts
================
import { env } from '@/config/env';
import { parseStringPromise } from 'xml2js';
import { LRUCache } from 'lru-cache';
import { loadingMessages } from './loadingStates';

interface ClaudeResponse {
  id: string;
  type: string;
  role: string;
  content: Array<{
    type: string;
    text: string;
  }>;
  model: string;
  stop_reason: string | null;
  usage: {
    input_tokens: number;
    output_tokens: number;
  };
}

const SENSITIVE_TOPICS_MESSAGE = "This topic involves sensitive or controversial subject matter. While we can explore factual historical and legal information, we'll maintain appropriate boundaries and focus on verified, publicly available information.";

// Initialize LRU cache with a maximum of 100 items that expire after 1 hour
const responseCache = new LRUCache({
  max: 100,
  ttl: 1000 * 60 * 60, // 1 hour
});

function handleSensitiveTopic(topic: string): { isAllowed: boolean; message?: string } {
  const lowercaseTopic = topic.toLowerCase();
  
  // Topics that should be handled with extra care
  if (lowercaseTopic.includes('epstein') || 
      // Add other sensitive topics as needed
      false) {
    return {
      isAllowed: true,
      message: SENSITIVE_TOPICS_MESSAGE
    };
  }

  return { isAllowed: true };
}

export type ProgressCallback = (message: string, progress: number) => void;

export async function generateTopicExploration(
  topic: string, 
  parentContext: string = '',
  onProgress?: ProgressCallback
) {
  try {
    // Update progress: Initial
    onProgress?.(loadingMessages.initial, 0);

    const cacheKey = `${topic}-${parentContext}`;
    const cachedResponse = responseCache.get(cacheKey);
    if (cachedResponse) {
      onProgress?.(loadingMessages.complete, 100);
      return cachedResponse;
    }

    // Update progress: Checking topic
    onProgress?.(loadingMessages.processing, 20);

    const { isAllowed, message } = handleSensitiveTopic(topic);
    if (!isAllowed) {
      onProgress?.(loadingMessages.complete, 100);
      return { summary: message, explorePaths: [], connections: [] };
    }

    // Update progress: Fetching
    onProgress?.(loadingMessages.fetching, 40);

    const sensitivityContext = message ? `\n\n${message}` : '';
    const contextString = parentContext ? 
      `This is part of a deeper exploration. Main topic: ${parentContext.split(' > ')[0]}. Path: ${parentContext}. Current: ${topic}${sensitivityContext}` 
      : sensitivityContext;

    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'anthropic-version': '2023-06-01',
        'x-api-key': env.CLAUDE_API_KEY
      },
      body: JSON.stringify({
        model: 'claude-3-5-sonnet-20241022',
        max_tokens: 4000,
        temperature: 0.7,
        system: `You are an expert knowledge exploration assistant. Generate concise, factual content in XML format.`,
        messages: [{
          role: 'user',
          content: `Explore "${topic}". ${contextString}\n\nFormat response in XML:\n<exploration>\n<summary>Concise summary</summary>\n<explorePaths><path><title>Title</title><description>Description</description><concepts>Concepts</concepts><relevantTopics>Topics</relevantTopics><researchAreas>Areas</researchAreas></path></explorePaths></exploration>`
        }]
      })
    });

    // Update progress: Processing response
    onProgress?.(loadingMessages.processing, 60);

    if (!response.ok) {
      onProgress?.(loadingMessages.error, 100);
      throw new Error(`API call failed: ${response.statusText}`);
    }

    const data: ClaudeResponse = await response.json();
    const xmlContent = data.content?.[0]?.text;
    
    if (!xmlContent) {
      onProgress?.(loadingMessages.error, 100);
      throw new Error('Invalid response from API');
    }

    // Update progress: Analyzing
    onProgress?.(loadingMessages.analyzing, 80);

    const xmlMatch = XML_PATTERN.exec(xmlContent);
    if (!xmlMatch) {
      onProgress?.(loadingMessages.complete, 100);
      return xmlContent.toLowerCase().includes('decline') || xmlContent.toLowerCase().includes('apologize')
        ? { summary: xmlContent, explorePaths: [], connections: [] }
        : { summary: 'Failed to parse response', explorePaths: [], connections: [] };
    }

    // Update progress: Finalizing
    onProgress?.(loadingMessages.finalizing, 90);

    const result = await parseClaudeResponse(xmlMatch[0]);
    responseCache.set(cacheKey, result);

    // Update progress: Complete
    onProgress?.(loadingMessages.complete, 100);
    
    return result;

  } catch (error) {
    // Update progress: Error
    onProgress?.(loadingMessages.error, 100);
    console.error('Error:', error instanceof Error ? error.message : String(error));
    throw error;
  }
}

async function parseClaudeResponse(xmlContent: string) {
  try {
    // Simplified cleaning
    const cleanXml = xmlContent
      .replace(/&(?!amp;|lt;|gt;|quot;|apos;)/g, '&amp;')
      .trim();

    // Streamlined parsing options
    const result = await parseStringPromise(cleanXml, { 
      explicitArray: false,
      mergeAttrs: true,
      normalize: true,
      tagNameProcessors: [(name) => name.toLowerCase()]
    });

    if (!result.exploration?.summary || !result.exploration?.explorepaths?.path) {
      throw new Error('Invalid XML structure: missing required elements');
    }

    const summary = result.exploration.summary;
    
    // Ensure path is always an array
    const paths = Array.isArray(result.exploration.explorepaths.path) 
      ? result.exploration.explorepaths.path 
      : [result.exploration.explorepaths.path];

    const explorePaths = paths.map((p: any) => ({
      title: p.title || '',
      description: p.description || '',
      concepts: p.concepts || '',
      relevantTopics: p.relevantTopics || '',
      researchAreas: p.researchAreas || ''
    }));

    return {
      summary,
      explorePaths,
      connections: []  // Simplified as we removed context from XML
    };
  } catch (error) {
    console.error('Error parsing XML response:', error);
    throw new Error('Failed to parse Claude response');
  }
}

// Optimize XML parsing with a more efficient regex
const XML_PATTERN = /<exploration>[\s\S]*?<\/exploration>/;

================
File: src/lib/loadingStates.ts
================
export type LoadingState = {
  isLoading: boolean;
  message: string;
  progress: number;
};

export const loadingMessages = {
  initial: 'Initiating exploration...',
  fetching: 'Gathering knowledge...',
  processing: 'Processing insights...',
  analyzing: 'Analyzing connections...',
  finalizing: 'Organizing results...',
  complete: 'Exploration complete!',
  error: 'Error occurred during exploration'
};

export const defaultLoadingState: LoadingState = {
  isLoading: false,
  message: '',
  progress: 0
};

================
File: src/types/css.d.ts
================
declare module '*.css' {
  const styles: { [className: string]: string }
  export default styles
}

declare module 'postcss' {
  export interface AtRule {
    name: string;
    params: string;
  }
}

// Add support for CSS Modules
declare module '*.module.css' {
  const classes: { [key: string]: string }
  export default classes
}

// Add support for Tailwind directives
interface TailwindDirective {
  (path: string): void
}

declare module 'tailwindcss' {
  const tailwind: TailwindDirective
  export default tailwind
}

declare module 'autoprefixer' {
  const autoprefixer: any;
  export default autoprefixer;
}

================
File: src/types/index.ts
================
export interface ExplorePath {
  title: string;
  description: string;
  concepts: string;
  relevantTopics: string;
  researchAreas: string;
}

export interface Topic {
  id: string;
  title: string;
  summary: string;
  explorePaths: ExplorePath[];
  connections: Connection[];
  parentId?: string;
  depth: number;
}

export interface Connection {
  id: string;
  title: string;
  description: string;
}

export interface ExplorationNode {
  id: string;
  title: string;
  children: ExplorationNode[];
  depth: number;
}

================
File: src/env.d.ts
================
/// <reference types="next" />
/// <reference types="next/image-types/global" />

declare namespace NodeJS {
  interface ProcessEnv {
    NEXT_PUBLIC_CLAUDE_API_KEY: string;
    NODE_ENV: 'development' | 'production' | 'test';
  }
}

declare module '*.css' {
  const content: { [className: string]: string };
  export default content;
}

declare namespace JSX {
  interface IntrinsicElements {
    [elemName: string]: any;
  }
}

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

================
File: next.config.js
================
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
}

module.exports = nextConfig

================
File: package.json
================
{
  "name": "rabbit-hole",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@types/xml2js": "^0.4.14",
    "d3": "7.9.0",
    "jsdom": "^26.0.0",
    "next": "14.1.0",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "uuid": "9.0.1",
    "xml2js": "^0.6.2"
  },
  "devDependencies": {
    "@types/d3": "7.4.3",
    "@types/jsdom": "^21.1.7",
    "@types/node": "20.11.0",
    "@types/react": "18.2.0",
    "@types/react-dom": "18.2.0",
    "@types/uuid": "9.0.7",
    "autoprefixer": "10.4.17",
    "eslint": "8.56.0",
    "eslint-config-next": "14.1.0",
    "postcss": "8.4.33",
    "tailwindcss": "3.4.1",
    "typescript": "5.3.3"
  }
}

================
File: postcss.config.js
================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================
File: tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}

================
File: terminal
================
cd ..
rm -rf rabbit-hole    # Remove the nested directory
rm -rf node_modules package-lock.json
npm install next@14.1.0 react@18.2.0 react-dom@18.2.0
npm install --save-dev typescript@5.3.3 @types/node@20.11.0 @types/react@18.2.0 @types/react-dom@18.2.0 @types/uuid@9.0.7 @types/d3@7.4.3
npm install d3@7.9.0 uuid@9.0.1
npm install react @types/react react-dom @types/react-dom --save
cat package.json | cat
pwd
ls node_modules/next/types
npm run dev

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
